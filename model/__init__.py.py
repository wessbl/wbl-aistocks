# -*- coding: utf-8 -*-
"""lstm-AIStockHelper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z96VjkJXcIOQ6KdNjEPjhmxKKfLd7FLH
"""

import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from keras.models import Sequential, load_model
from keras.layers import Dense, LSTM
from sklearn.preprocessing import MinMaxScaler

# LSTM Performance Variables
ticker = 'AAPL'         # MSFT | DAC | AAPL
years = 10              #  5  | 10  |
time_step = 75          # 50  | 100 |
lstm_unit = 75          # 50  | 64  | 100-200, choose one layer only
dnse_unit = 32          #  1  | 64  | choose < 5 layers no more than 128
batch = 64              # 32  | 64  |
epochs = 1              # 10  | 50  | 100
save_model = True       # True False - just helps prevent time while editing
verbose = True          # Display outputs
offset = 0              # Slide predictions to match real values

# Other Variables
model_filename = 'lstm-' + ticker + '.keras'
db_path = 'models.db'
arch_filename = 'model_architecture.png'
start_date = '2014-01-01'
last_update = pd.Timestamp('2023-12-31')
model = None
orig_data = None
scaled_data = None
X = np.array([])
scaler = MinMaxScaler(feature_range=(0,1))

#--- Function: Create the dataset for LSTM ---#
def create_dataset(data):
  X, y = [], []
  for i in range(len(data) - time_step - 1):
    X.append(data[i:(i + time_step), 0])
    y.append(data[i + time_step, 0])
  return np.array(X), np.array(y)
#---------------------------------------------#


#--- Function: Preprocess data ---#
def preprocess(df):
  global orig_data, scaler, scaled_data, X, y
  orig_data = df['Close'].values
  orig_data = orig_data.reshape(-1, 1)    # Reshape into a 2d array: [[1], [2], [3]]
  scaler = MinMaxScaler(feature_range=(0,1))
  scaled_data = scaler.fit_transform(orig_data)

  # Create Datasets to feed LSTM
  X, y = create_dataset(scaled_data)
  X = X.reshape(X.shape[0], X.shape[1], 1)
  return
#---------------------------------#


#--- Function: Train a new or existing model ---#
def train_model(model):
  # Build and compile the LSTM, if needed
  if (model == None):
    model = Sequential()
    model.add(LSTM(lstm_unit, return_sequences=True, input_shape=(time_step, 1)))
    model.add(LSTM(lstm_unit))
    model.add(Dense(dnse_unit))
    model.add(Dense(5)) # Capture weekly cycles, 5 trading days/week
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')

  # Train model
  model.fit(X, y, epochs=epochs, batch_size=batch)
  if verbose: print("Model is trained!")
  return model
#-----------------------------------------------#

##### SQL Functions #####
import sqlite3
import tempfile

#--- Function: Save to DB ---#
def save(ticker, model, last_update, result=''):
  # Connect to db
  conn = sqlite3.connect(db_path)
  cursor = conn.cursor()

  # Create table if necessary
  cursor.execute('''
    CREATE TABLE IF NOT EXISTS models (
      ticker TEXT PRIMARY KEY,
      model BLOB,
      last_update TEXT,
      result TEXT
    )
  ''')

  # Serialize model
  with tempfile.NamedTemporaryFile(suffix='.keras') as temp_file:      # TODO try .h5
    model.save(temp_file.name)
    temp_file.seek(0)
    blob = temp_file.read()

  # Reformat timestamp
  last_update_txt = last_update.strftime("%Y-%m-%d")

  # Insert Row
  cursor.execute('''
    INSERT OR REPLACE INTO models (ticker, model, last_update, result)
    VALUES (?, ?, ?, ?)''',
    (ticker, blob, last_update_txt, result))
  conn.commit()
  conn.close()
#------------------------------#

#--- Function: Load from DB ---#
def load(ticker):
  conn = sqlite3.connect(db_path)
  cursor = conn.cursor()
  cursor.execute('''
    SELECT model, last_update, result FROM models WHERE ticker = ?''',
                (ticker,))
  row = cursor.fetchone()

  if row:
    blob, last_update_text, result = row

    with tempfile.NamedTemporaryFile(suffix='.keras') as temp_file:
      temp_file.write(blob)
      temp_file.flush()
      model = load_model(temp_file.name)

    last_update = pd.Timestamp(last_update_text)
    conn.close()
    if verbose: print("\nLoaded data from database!\nModel:\t\t", model,
        "\nLast Update:\t", last_update, "\nResult:\t\t", result)
    return model, last_update, result
  else:
    conn.close()
    raise ValueError("Model could not be found in the database.")
#------------------------------#

# First, try to load the model (to prevent training time)
try:
  # Load the model if needed
  if save_model:
    model, last_update, result = load(ticker)
  if verbose: print("\nModel loaded!")

  # Process data if needed
  if (orig_data is None) or (len(orig_data) == 0):
    preprocess(yf.download(ticker, start=start_date, end=last_update))
    if verbose: print('Data loaded & processed!')

except Exception:
  # Download stock data for given years (pretend today is 12/31/23 for now)
  if verbose: print("\nFetching data...")
  preprocess(yf.download(ticker, start=start_date, end=last_update))

  # Train a new model
  if verbose: print("Training model...")
  model = train_model(model)

  #Save the model!
  if (save_model):
    save(ticker, model, last_update)
    if verbose: print("Model saved!")
  else:
    if verbose: print("Not saved!")

#--- Function: Show how model mirrors actual data ---#
def mirror_data(model):
  mirror = model.predict(X)[offset:]
  mirror = scaler.inverse_transform(mirror)
  return mirror
#-----------------------------------------------#

#--- Function: Display entire price history ---#
def show_complete(mirror):
  start = time_step
  end = start + len(mirror)
  plt.figure(figsize=(8, 3))
  plt.plot(orig_data, label="Actual Price")
  plt.plot(np.arange(start, end), mirror, label='Model Prediction')
  plt.legend()
  plt.show()
#-----------------------------------------------#

#--- Function: Display last part of mirror, zoomed in ---#
def show_zoom(mirror, width):
  zoom_data = orig_data[-width:]
  zoom_predict = mirror[-width:]

  plt.figure(figsize=(8, 3))
  plt.plot(zoom_data, label="Actual Price")
  plt.plot(zoom_predict, label='Prediction')
  plt.legend()
  plt.show()
#-----------------------------------------------#

mirror = mirror_data(model)
show_complete(mirror)
show_zoom(mirror, 500)
show_zoom(mirror, 100)

def get_model_img():
  from keras.utils import plot_model
  from IPython.display import Image

  # Assuming 'model' is your Keras model
  plot_model(model, to_file=arch_filename, show_shapes=True, show_layer_names=True)
  Image(arch_filename)

#get_model_img()

#--- Function: Predict price over future given days ---#
def predict(days):
  multi_day_data = scaled_data[-time_step:]
  X_predict = multi_day_data[:time_step].reshape(1, time_step, 1)

  # Create an array with the first index at last known close price
  prediction = []
  prediction.append(orig_data[len(orig_data) - 1][0])

  # Predict the next 5 days' prices iteratively
  for i in range(days):
      # Predict the next day's price
      scaled_price = model.predict(X_predict)
      actual_price = scaler.inverse_transform(scaled_price.reshape(-1, 1))
      prediction.append(actual_price[0, 0])

      # Update the input sequence for the next prediction
      multi_day_data = np.append(multi_day_data, scaled_price)
      X_predict = multi_day_data[-time_step:].reshape(1, time_step, 1)

  # Plot the prediction!
  zoom_data = orig_data[-time_step:]
  dividing_line = time_step - 1
  end = dividing_line + len(prediction)
  plt.figure(figsize=(8, 3))
  plt.axvline(x=dividing_line, color='grey', linestyle=':', label='Last Known Price')
  plt.plot(zoom_data, label="Actual Price")
  plt.plot(np.arange(dividing_line, end), prediction, label='Prediction')
  plt.legend()
  plt.show()

  return prediction
#------------------------------------------------------#

original_prediction = predict(5)

### Update Model ###
from datetime import datetime, timedelta
import pytz

#--- Function: Train the model on the latest closing price ---#
def update_model():
  global last_update

  # Get the current time & day
  now = datetime.now(pytz.timezone('US/Eastern'))
  today = now.date()

  # If the market is closed and we have already updated, return
  market_close_time = now.replace(hour=16, minute=0, second=0)
  market_closed = market_close_time <= now
  if market_closed & (last_update == today):
    return False, "Model is already updated on today's market close."

  # Get 'yesterday': the last market close before today
  yesterday = today - timedelta(days=1)
  two_weeks = now - timedelta(days=10)
  minidata = yf.download(ticker, start=two_weeks, end=yesterday)
  minidata.reset_index(inplace=True)
  minidata = minidata['Date']
  yesterday = minidata[len(minidata) - 1]
  yesterday = yesterday.to_pydatetime().date()

  # If the market isn't closed but last update was yesterday, return
  if (not market_closed) & (last_update == yesterday):
    return False, "Model is already updated to previous market close."

  # Update model with all close prices from original start date
  if (not market_closed):
    today = yesterday
  df = yf.download(ticker, start=start_date, end=today)
  preprocess(df)
  model.fit(X, y, epochs=epochs, batch_size=batch)
  last_update = today
  dates = 'Updated model: ' + start_date + ' through ' + last_update.strftime("%Y-%m-%d") + '. '
  return True, dates
#-------------------------------------------------------------#
#last_update = pd.Timestamp('2023-12-31') #Force update
status, expl = update_model()
if verbose: print("\nModel Updated:\t", status, "\nExplanation:\t", expl)

if verbose:
  mirror = mirror_data(model)
  show_complete(mirror)
  show_zoom(mirror, 500)
  show_zoom(mirror, 100)

new_prediction = predict(5)

#--- Function: Determine whether to buy or sell stock ---#
def buy_or_sell(prediction):
  last_price = orig_data[len(orig_data) - 1][0]
  last_predicted = prediction[len(prediction) - 1]
  percent = (last_predicted * 100 / last_price)

  if last_price <= last_predicted:
    percent = percent - 100
    percent = str(f"{percent:.2f}")
    return "Buy: AIStockHelper says this stock will go up in value by " + percent + "%."
  else:
    percent = 100 - percent
    percent = str(f"{percent:.2f}")
    return "Sell: AIStockHelper says this stock will go down in value by " + percent + "%."
#---------------------------------------------------------#

recommendation = buy_or_sell(new_prediction)
if verbose: print(recommendation)
if (save_model):
  save(ticker, model, last_update, recommendation)
  if verbose: print("Model saved!")

# Final test: reload model, make a prediction, compare with last prediction
model = None
model, last_update, result = load(ticker)
last_prediction = predict(5)
if verbose: print(buy_or_sell(last_prediction))

# Load and save a bajillion times for testing
# model = None
# model, last_update, result = load(ticker)
# model, last_update, result = load(ticker)
# model, last_update, result = load(ticker)
# save(ticker, model, last_update, recommendation)
# model, last_update, result = load(ticker)
# save(ticker, model, last_update, recommendation)
# save(ticker, model, last_update, recommendation)
# save(ticker, model, last_update, recommendation)